#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import errno
import socket
import time
import json

import eventlet
eventlet.patcher.monkey_patch(all=False, socket=True)
import eventlet.wsgi
from oslo_config import cfg
from oslo_log import log as logging
from oslo_log import loggers
from oslo_service import service
from oslo_service import sslutils
import routes.middleware
import webob.dec
import webob.exc

wsgi_opts = [
    cfg.IntOpt('backlog',
               default=4096,
               help="Number of backlog requests to configure the socket with"),
    cfg.IntOpt('tcp_keepidle',
               default=600,
               help="Sets the value of TCP_KEEPIDLE in seconds for each "
                    "server socket. Not supported on OS X."),
    cfg.IntOpt('max_header_line',
               default=16384,
               help="Maximum line size of message headers to be accepted. "
                    "max_header_line may need to be increased when using "
                    "large tokens (typically those generated by the "
                    "Keystone v3 API with big service catalogs)."),
]

CONF = cfg.CONF
CONF.register_opts(wsgi_opts)

LOG = logging.getLogger(__name__)


class Service(service.Service):

    def __init__(self, application, port,
                 host='0.0.0.0', backlog=4096, threads=1000):
        self.application = application
        self._port = port
        self._host = host
        self._backlog = backlog if backlog else CONF.backlog
        super(Service, self).__init__(threads)

    def _get_socket(self, host, port, backlog):
        info = socket.getaddrinfo(host,
                                  port,
                                  socket.AF_UNSPEC,
                                  socket.SOCK_STREAM)[0]
        family = info[0]
        bind_addr = info[-1]

        sock = None
        retry_until = time.time() + 30
        while not sock and time.time() < retry_until:
            try:
                sock = eventlet.listen(bind_addr,
                                       backlog=backlog,
                                       family=family)
                if sslutils.is_enabled(CONF):
                    sock = sslutils.wrap(CONF, sock)

            except socket.error as err:
                if err.args[0] != errno.EADDRINUSE:
                    raise
                eventlet.sleep(0.1)
        if not sock:
            raise RuntimeError("Could not bind to %(host)s:%(port)s "
                               "after trying for 30 seconds" %
                               {'host': host, 'port': port})
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)

        if hasattr(socket, 'TCP_KEEPIDLE'):
            sock.setsockopt(socket.IPPROTO_TCP,
                            socket.TCP_KEEPIDLE,
                            CONF.tcp_keepidle)

        return sock

    def start(self):
        super(Service, self).start()
        self._socket = self._get_socket(self._host, self._port, self._backlog)
        self.tg.add_thread(self._run, self.application, self._socket)

    @property
    def backlog(self):
        return self._backlog

    @property
    def host(self):
        return self._socket.getsockname()[0] if self._socket else self._host

    @property
    def port(self):
        return self._socket.getsockname()[1] if self._socket else self._port

    def stop(self):
        super(Service, self).stop()

    def reset(self):
        super(Service, self).reset()
        logging.setup(cfg.CONF, 'murano')

    def _run(self, application, socket):
        logger = logging.getLogger('eventlet.wsgi')
        eventlet.wsgi.MAX_HEADER_LINE = CONF.max_header_line
        eventlet.wsgi.server(socket,
                             application,
                             custom_pool=self.tg.pool,
                             log=loggers.WritableLogger(logger))


class Router(object):
    def __init__(self, mapper):
        self.map = mapper
        self._router = routes.middleware.RoutesMiddleware(self._dispatch, self.map)

    @webob.dec.wsgify
    def __call__(self, req):
        return self._router

    @staticmethod
    @webob.dec.wsgify
    def _dispatch(req):
        match = req.environ['wsgiorg.routing_args'][1]
        if not match:
            return webob.exc.HTTPNotFound()
        app = match['controller']
        return app


class Request(webob.Request):
    pass


class Resource(object):

    def __init__(self, controller):
        self.controller = controller

    @webob.dec.wsgify(RequestClass=Request)
    def __call__(self, request):
        action, action_args = self.deserialize_request(request)
        action_result = self.dispatch(self.controller, action, request, **action_args)
        return self.serialize_response(action_result)

    def deserialize_request(self, request):
        action_args = self.get_action_args(request.environ)
        action = action_args.pop('action', 'index')
        action_args.pop('path', None)

        return action, action_args

    def serialize_response(self, result):
        if isinstance(result, webob.Response):
            return result

        response = webob.Response()

        response.headers['Content-Type'] = 'application/json'
        response.body = json.dumps(result)

        return response

    def dispatch(self, obj, action, *args, **kwargs):
        try:
            method = getattr(obj, action)
        except AttributeError:
            method = getattr(obj, 'default')

        return method(*args, **kwargs)

    def get_action_args(self, request_environment):
        try:
            args = request_environment['wsgiorg.routing_args'][1].copy()
        except Exception:
            return {}

        try:
            del args['controller']
        except KeyError:
            pass

        try:
            del args['format']
        except KeyError:
            pass

        return args

